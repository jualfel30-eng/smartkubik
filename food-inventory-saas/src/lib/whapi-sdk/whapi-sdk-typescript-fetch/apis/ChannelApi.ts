/* tslint:disable */
/* eslint-disable */
/**
 * Whapi API
 * Sending and receiving messages using HTTP requests. Fixed price with no hidden fees, without limits and restrictions. You will be able to send and receive text/media/files/locations/goods/orders/polls messages via WhatsApp in private or group chats. Guides and SDK can be found on our website.
 *
 * The version of the OpenAPI document: 1.8.7
 * Contact: care@whapi.cloud
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  Event,
  Health,
  Limits,
  ResponseError,
  ResponseSuccess,
  Settings,
  UpdateSettings,
  WebhookTestRequest,
} from '../models/index';
import {
    EventFromJSON,
    EventToJSON,
    HealthFromJSON,
    HealthToJSON,
    LimitsFromJSON,
    LimitsToJSON,
    ResponseErrorFromJSON,
    ResponseErrorToJSON,
    ResponseSuccessFromJSON,
    ResponseSuccessToJSON,
    SettingsFromJSON,
    SettingsToJSON,
    UpdateSettingsFromJSON,
    UpdateSettingsToJSON,
    WebhookTestRequestFromJSON,
    WebhookTestRequestToJSON,
} from '../models/index';

export interface CheckHealthRequest {
    wakeup?: boolean;
    platform?: string;
    channelType?: CheckHealthChannelTypeEnum;
}

export interface GetChannelSettingsRequest {
    body?: object;
}

export interface UpdateChannelSettingsRequest {
    settings?: Settings;
}

export interface WebhookTestOperationRequest {
    webhookTestRequest?: WebhookTestRequest;
}

/**
 * 
 */
export class ChannelApi extends runtime.BaseAPI {

    /**
     * Allows you to track and get feedback on the operational status of the whapi channel (instance). An instance is a connection with a phone number that has a WhatsApp account, which will be responsible for sending and receiving messages
     * Check health & launch channel
     */
    async checkHealthRaw(requestParameters: CheckHealthRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Health>> {
        const queryParameters: any = {};

        if (requestParameters['wakeup'] != null) {
            queryParameters['wakeup'] = requestParameters['wakeup'];
        }

        if (requestParameters['platform'] != null) {
            queryParameters['platform'] = requestParameters['platform'];
        }

        if (requestParameters['channelType'] != null) {
            queryParameters['channel_type'] = requestParameters['channelType'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["token"] = await this.configuration.apiKey("token"); // tokenAuth authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/health`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => HealthFromJSON(jsonValue));
    }

    /**
     * Allows you to track and get feedback on the operational status of the whapi channel (instance). An instance is a connection with a phone number that has a WhatsApp account, which will be responsible for sending and receiving messages
     * Check health & launch channel
     */
    async checkHealth(requestParameters: CheckHealthRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Health> {
        const response = await this.checkHealthRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of specific events that you can be notified about when Webhook is configured
     * Get allowed events
     */
    async getAllowedEventsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Event>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["token"] = await this.configuration.apiKey("token"); // tokenAuth authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/settings/events`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(EventFromJSON));
    }

    /**
     * Get a list of specific events that you can be notified about when Webhook is configured
     * Get allowed events
     */
    async getAllowedEvents(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Event>> {
        const response = await this.getAllowedEventsRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get channel settings
     */
    async getChannelSettingsRaw(requestParameters: GetChannelSettingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Settings>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["token"] = await this.configuration.apiKey("token"); // tokenAuth authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/settings`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['body'] as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SettingsFromJSON(jsonValue));
    }

    /**
     * Get channel settings
     */
    async getChannelSettings(requestParameters: GetChannelSettingsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Settings> {
        const response = await this.getChannelSettingsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Sandbox as well as Trials have some limitations. This endpoint allows you to get information about the remaining and used limits on your channel
     * Get limits
     */
    async getLimitsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Limits>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["token"] = await this.configuration.apiKey("token"); // tokenAuth authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/limits`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LimitsFromJSON(jsonValue));
    }

    /**
     * Sandbox as well as Trials have some limitations. This endpoint allows you to get information about the remaining and used limits on your channel
     * Get limits
     */
    async getLimits(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Limits> {
        const response = await this.getLimitsRaw(initOverrides);
        return await response.value();
    }

    /**
     * Reset channel settings
     */
    async resetChannelSettingsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ResponseSuccess>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["token"] = await this.configuration.apiKey("token"); // tokenAuth authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/settings`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ResponseSuccessFromJSON(jsonValue));
    }

    /**
     * Reset channel settings
     */
    async resetChannelSettings(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ResponseSuccess> {
        const response = await this.resetChannelSettingsRaw(initOverrides);
        return await response.value();
    }

    /**
     * If a field is not present in the request, no change is made to that setting. For example, if \'proxy\' is not sent with the request, the existing configuration for \'proxy\' is unchanged.
     * Update channel settings
     */
    async updateChannelSettingsRaw(requestParameters: UpdateChannelSettingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UpdateSettings>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["token"] = await this.configuration.apiKey("token"); // tokenAuth authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/settings`,
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: SettingsToJSON(requestParameters['settings']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UpdateSettingsFromJSON(jsonValue));
    }

    /**
     * If a field is not present in the request, no change is made to that setting. For example, if \'proxy\' is not sent with the request, the existing configuration for \'proxy\' is unchanged.
     * Update channel settings
     */
    async updateChannelSettings(requestParameters: UpdateChannelSettingsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UpdateSettings> {
        const response = await this.updateChannelSettingsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * For testing webhook.
     * Test webhook
     */
    async webhookTestRaw(requestParameters: WebhookTestOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ResponseSuccess>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["token"] = await this.configuration.apiKey("token"); // tokenAuth authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/settings/webhook_test`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: WebhookTestRequestToJSON(requestParameters['webhookTestRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ResponseSuccessFromJSON(jsonValue));
    }

    /**
     * For testing webhook.
     * Test webhook
     */
    async webhookTest(requestParameters: WebhookTestOperationRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ResponseSuccess> {
        const response = await this.webhookTestRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const CheckHealthChannelTypeEnum = {
    Web: 'web',
    Mobile: 'mobile'
} as const;
export type CheckHealthChannelTypeEnum = typeof CheckHealthChannelTypeEnum[keyof typeof CheckHealthChannelTypeEnum];
